<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>DotBot</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://cdn.jsdelivr.net/npm/marked@12/marked.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/dompurify@3/dist/purify.min.js"></script>
  <script>
    tailwind.config = {
      theme: {
        extend: {
          colors: {
            'dot-bg': '#0a0a0a',
            'dot-panel': '#111111',
            'dot-header': '#1a1a2e',
            'dot-border': '#333333',
            'dot-cyan': '#00d9ff',
            'dot-user': '#1e3a5f',
            'dot-assistant': '#2a2a3e',
          }
        }
      }
    }
  </script>
  <style>
    .scrollbar-thin::-webkit-scrollbar { width: 6px; height: 6px; }
    .scrollbar-thin::-webkit-scrollbar-track { background: #1a1a1a; }
    .scrollbar-thin::-webkit-scrollbar-thumb { background: #444; border-radius: 3px; }
    .scrollbar-thin::-webkit-scrollbar-thumb:hover { background: #555; }
    .log-entry { font-family: 'Fira Code', 'Consolas', monospace; }
    .tab-active { border-bottom: 2px solid #00d9ff; color: #00d9ff; }
    .tab-inactive { border-bottom: 2px solid transparent; color: #6b7280; }
    .tab-inactive:hover { color: #9ca3af; }
    .agent-card { border-left: 3px solid #00d9ff; cursor: pointer; }
    .agent-card.completed { border-left-color: #22c55e; }
    .agent-card.failed { border-left-color: #ef4444; }
    .agent-card:hover { background: rgba(255,255,255,0.03); }
    .agent-card.researching { border-left-color: #a78bfa; }
    .agent-card.blocked { border-left-color: #facc15; }
    .agent-timeline { max-height: 300px; overflow-y: auto; }
    .timeline-event { font-family: 'Fira Code', 'Consolas', monospace; font-size: 10px; }
    .timeline-event.tool_call { color: #00d9ff; }
    .timeline-event.tool_result { color: #9ca3af; }
    .timeline-event.tool_result.success { color: #22c55e; }
    .timeline-event.tool_result.fail { color: #ef4444; }
    .timeline-event.status { color: #facc15; }
    @keyframes pulse-dot { 0%, 100% { opacity: 1; } 50% { opacity: 0.4; } }
    .pulse-dot { animation: pulse-dot 1.5s ease-in-out infinite; }
    .agent-label { display: inline-block; font-size: 11px; font-weight: 600; padding: 1px 8px; border-radius: 4px; margin-bottom: 4px; }
    .agent-label-default { background: rgba(0,217,255,0.15); color: #00d9ff; }
    .agent-convo-modal { max-height: 70vh; overflow-y: auto; }

    /* Markdown rendered content */
    .md-content h1 { font-size: 1.25rem; font-weight: 700; margin: 0.75rem 0 0.5rem; color: #e5e7eb; }
    .md-content h2 { font-size: 1.1rem; font-weight: 600; margin: 0.6rem 0 0.4rem; color: #d1d5db; }
    .md-content h3 { font-size: 1rem; font-weight: 600; margin: 0.5rem 0 0.3rem; color: #d1d5db; }
    .md-content p { margin: 0.4rem 0; line-height: 1.6; }
    .md-content ul, .md-content ol { margin: 0.4rem 0 0.4rem 1.25rem; }
    .md-content ul { list-style-type: disc; }
    .md-content ol { list-style-type: decimal; }
    .md-content li { margin: 0.15rem 0; line-height: 1.5; }
    .md-content li > ul, .md-content li > ol { margin: 0.1rem 0 0.1rem 1rem; }
    .md-content strong { color: #f3f4f6; font-weight: 600; }
    .md-content em { color: #d1d5db; font-style: italic; }
    .md-content code { background: rgba(0,0,0,0.4); color: #00d9ff; padding: 0.1rem 0.35rem; border-radius: 3px; font-size: 0.85em; font-family: 'Fira Code', 'Consolas', monospace; }
    .md-content pre { background: rgba(0,0,0,0.5); border: 1px solid #333; border-radius: 6px; padding: 0.75rem; margin: 0.5rem 0; overflow-x: auto; }
    .md-content pre code { background: none; color: #e5e7eb; padding: 0; font-size: 0.8em; }
    .md-content blockquote { border-left: 3px solid #00d9ff; padding: 0.25rem 0.75rem; margin: 0.5rem 0; color: #9ca3af; background: rgba(0,217,255,0.05); border-radius: 0 4px 4px 0; }
    .md-content a { color: #00d9ff; text-decoration: underline; text-underline-offset: 2px; }
    .md-content a:hover { color: #67e8f9; }
    .md-content hr { border: none; border-top: 1px solid #333; margin: 0.75rem 0; }
    .md-content table { border-collapse: collapse; margin: 0.5rem 0; width: 100%; }
    .md-content th, .md-content td { border: 1px solid #333; padding: 0.35rem 0.6rem; text-align: left; font-size: 0.9em; }
    .md-content th { background: rgba(0,0,0,0.3); color: #d1d5db; font-weight: 600; }
    .md-content > *:first-child { margin-top: 0; }
    .md-content > *:last-child { margin-bottom: 0; }
  </style>
</head>
<body class="bg-dot-bg text-gray-200 h-screen flex flex-col overflow-hidden">
  
  <!-- Header -->
  <header class="bg-dot-header border-b border-dot-border px-4 py-3 flex items-center gap-4 shrink-0">
    <h1 class="text-xl font-bold text-dot-cyan">ü§ñ DotBot</h1>
    <div class="ml-auto flex items-center gap-2 text-sm">
      <span id="statusDot" class="w-2.5 h-2.5 rounded-full bg-red-500"></span>
      <span id="statusText">Disconnected</span>
    </div>
    <button 
      id="toggleDebug" 
      onclick="toggleDebugPanel()"
      class="px-3 py-1 text-xs bg-dot-panel border border-dot-border rounded hover:bg-gray-800 transition"
    >
      <span id="toggleDebugText">Hide Debug</span>
    </button>
    <button 
      onclick="showServerSettings()"
      class="px-3 py-1 text-xs bg-dot-panel border border-dot-border rounded hover:bg-gray-800 transition"
      title="Server Settings"
    >‚öôÔ∏è</button>
  </header>
  
  <!-- Main Layout -->
  <div class="flex-1 flex overflow-hidden">
    
    <!-- Left Panel (Tabbed: Debug | Agents) -->
    <aside id="debugPanel" class="w-[450px] bg-dot-panel border-r border-dot-border flex flex-col shrink-0 transition-all duration-300">
      <!-- Tab Bar -->
      <div class="flex border-b border-dot-border bg-gray-900/50 shrink-0">
        <button id="tabDebug" onclick="switchTab('debug')" class="flex-1 px-3 py-2 text-xs font-semibold uppercase tracking-wide tab-active transition">
          Debug
        </button>
        <button id="tabAgents" onclick="switchTab('agents')" class="flex-1 px-3 py-2 text-xs font-semibold uppercase tracking-wide tab-inactive transition relative">
          Agents
          <span id="agentCountBadge" class="hidden absolute top-1 right-2 w-4 h-4 bg-dot-cyan text-black text-[10px] font-bold rounded-full flex items-center justify-center">0</span>
        </button>
        <div class="flex items-center gap-2 px-2">
          <button onclick="clearLogs()" class="text-xs text-gray-500 hover:text-gray-300">Clear</button>
          <span id="llmInfo" class="text-xs text-dot-cyan">...</span>
        </div>
      </div>
      
      <!-- Debug Tab Content -->
      <div id="tabContentDebug" class="flex-1 overflow-y-auto p-2 space-y-1 scrollbar-thin text-[11px]">
        <div id="debugLogs"></div>
      </div>
      
      <!-- Agents Tab Content -->
      <div id="tabContentAgents" class="flex-1 overflow-y-auto p-2 space-y-2 scrollbar-thin hidden">
        <div id="agentTasksList" class="space-y-2">
          <div id="noAgentsMsg" class="text-center text-sm text-gray-500 py-8">
            No agent tasks yet. Send a request to see agents here.
          </div>
        </div>
      </div>
    </aside>
    
    <!-- Chat Area (Right) -->
    <main class="flex-1 flex flex-col min-w-0">
      <!-- Messages -->
      <div id="messages" class="flex-1 overflow-y-auto p-4 space-y-3 scrollbar-thin">
        <div class="text-center text-sm text-gray-500 py-4">
          Welcome to DotBot. Type a message to get started.
        </div>
      </div>
      
      <!-- Input Area -->
      <div class="border-t border-dot-border bg-dot-header p-4">
        <div class="flex gap-3 max-w-4xl mx-auto">
          <textarea 
            id="input" 
            placeholder="Type your message..." 
            rows="1"
            onkeydown="handleKeyDown(event)"
            class="flex-1 px-4 py-3 bg-dot-bg border border-dot-border rounded-lg text-gray-200 placeholder-gray-500 resize-none focus:outline-none focus:border-dot-cyan transition"
          ></textarea>
          <button 
            id="sendBtn" 
            onclick="sendMessage()"
            class="px-6 py-3 bg-dot-cyan text-black font-semibold rounded-lg hover:bg-cyan-400 disabled:bg-gray-700 disabled:text-gray-500 disabled:cursor-not-allowed transition"
          >Send</button>
        </div>
      </div>
    </main>
  </div>
  
  <!-- Disconnect Overlay -->
  <div id="disconnectOverlay" class="fixed inset-0 bg-black/90 flex flex-col items-center justify-center z-50">
    <h2 class="text-5xl font-bold text-red-500 mb-4">‚ö° DISCONNECTED</h2>
    <p id="disconnectReason" class="text-gray-500 mb-2">Server connection lost</p>
    <p id="disconnectUrl" class="text-gray-600 text-xs mb-6 font-mono"></p>
    <div id="reconnectStatus" class="text-dot-cyan text-sm mb-4">Attempting to reconnect...</div>
    <button onclick="showServerSettings()" class="px-4 py-2 bg-dot-panel border border-dot-border rounded hover:bg-gray-800 text-sm transition">‚öôÔ∏è Connection Settings</button>
  </div>

  <!-- Server Settings Modal -->
  <div id="serverSettingsModal" class="fixed inset-0 bg-black/80 flex items-center justify-center z-[60] hidden">
    <div class="bg-dot-panel border border-dot-border rounded-lg p-6 w-[420px]">
      <h3 class="text-lg font-bold text-dot-cyan mb-4">Server Connection</h3>
      <label class="block text-sm text-gray-400 mb-1">WebSocket URL</label>
      <input id="serverUrlInput" type="text" placeholder="wss://your-server.com:3001"
        onkeydown="if(event.key==='Enter')saveServerSettings()"
        class="w-full px-3 py-2 bg-dot-bg border border-dot-border rounded text-gray-200 text-sm font-mono focus:outline-none focus:border-dot-cyan mb-4" />
      <p class="text-xs text-gray-500 mb-4">Enter the WebSocket URL of your DotBot server.<br/>Use <span class="text-gray-400">ws://</span> for local or <span class="text-gray-400">wss://</span> for remote.</p>
      <div class="text-xs text-gray-500 mb-4 p-3 bg-yellow-900/20 border border-yellow-700/30 rounded">
        ‚ö†Ô∏è <strong>Device credentials required:</strong> Web clients now use device credentials instead of a global auth token.<br/>
        To connect, include <span class="text-gray-400">deviceId</span> and <span class="text-gray-400">secret</span> in the URL hash (e.g., <span class="text-gray-400">#deviceId=...&secret=...</span>),<br/>
        or use the setup link provided by your local agent.
      </div>
      <div class="flex gap-2 justify-end">
        <button onclick="closeServerSettings()" class="px-4 py-2 text-sm text-gray-400 hover:text-gray-200 transition">Cancel</button>
        <button onclick="saveServerSettings()" class="px-4 py-2 bg-dot-cyan text-black text-sm font-semibold rounded hover:bg-cyan-400 transition">Connect</button>
      </div>
    </div>
  </div>

  <!-- Agent Conversation Modal -->
  <div id="agentConvoModal" class="fixed inset-0 bg-black/80 flex items-center justify-center z-[60] hidden">
    <div class="bg-dot-panel border border-dot-border rounded-lg p-6 w-[600px] max-h-[80vh] flex flex-col">
      <div class="flex items-center justify-between mb-4 shrink-0">
        <h3 id="agentConvoTitle" class="text-lg font-bold text-dot-cyan">Agent Conversation</h3>
        <button onclick="closeAgentConvo()" class="text-gray-400 hover:text-gray-200 text-xl">&times;</button>
      </div>
      <div id="agentConvoBody" class="agent-convo-modal space-y-2 scrollbar-thin flex-1"></div>
    </div>
  </div>

  <script>
    // Resolve server URL and device credentials from hash fragment or query params.
    // Hash fragments (#ws=...&deviceId=...&secret=...) are preferred for file:// protocol because
    // Windows Start-Process/ShellExecute strips query params (?) from file:// URLs.
    // Device credentials are NOT stored in localStorage to prevent XSS exfiltration.
    function resolveConfig() {
      // Check hash fragment first (works with file:// protocol)
      const hashParams = new URLSearchParams(window.location.hash.slice(1));
      // Fall back to query params (works with http:// protocol)
      const queryParams = new URLSearchParams(window.location.search);

      const paramUrl = hashParams.get('ws') || queryParams.get('ws');
      const paramDeviceId = hashParams.get('deviceId') || queryParams.get('deviceId');
      const paramSecret = hashParams.get('secret') || queryParams.get('secret');

      // Store only the WebSocket URL (not credentials)
      if (paramUrl) localStorage.setItem('dotbot_ws_url', paramUrl);

      // Clear URL to remove credentials from address bar and browser history
      if (paramUrl || paramDeviceId || paramSecret) {
        try {
          window.history.replaceState({}, '', window.location.pathname);
          if (window.location.hash) window.location.hash = '';
        } catch(e) {}
      }

      return {
        url: paramUrl || localStorage.getItem('dotbot_ws_url') || 'ws://localhost:3001',
        deviceId: paramDeviceId || '',
        deviceSecret: paramSecret || '',
      };
    }
    const config = resolveConfig();
    let WS_URL = config.url;
    let DEVICE_ID = config.deviceId;
    let DEVICE_SECRET = config.deviceSecret;
    
    let ws = null;
    let isConnected = false;
    let authErrorReason = '';
    let currentStreamMessage = null;
    let currentStreamRaw = '';
    let debugPanelVisible = true;
    let llmProvider = 'unknown';
    let llmModel = 'unknown';
    let activeTab = 'debug';
    
    // Agent task tracking
    const agentTasks = new Map(); // taskId ‚Üí { taskId, taskName, personaId, status, startedAt, activity, toolCalls, events[], expanded }
    let agentTimerInterval = null;
    
    const messagesEl = document.getElementById('messages');
    const inputEl = document.getElementById('input');
    const sendBtn = document.getElementById('sendBtn');
    const statusDot = document.getElementById('statusDot');
    const statusText = document.getElementById('statusText');
    const debugLogs = document.getElementById('debugLogs');
    const debugPanel = document.getElementById('debugPanel');
    const llmInfo = document.getElementById('llmInfo');
    const agentTasksList = document.getElementById('agentTasksList');
    const noAgentsMsg = document.getElementById('noAgentsMsg');
    const agentCountBadge = document.getElementById('agentCountBadge');
    
    // Log types and colors
    const LOG_COLORS = {
      'client-send': 'text-blue-400',
      'client-recv': 'text-green-400', 
      'server': 'text-purple-400',
      'llm': 'text-yellow-400',
      'error': 'text-red-400',
      'info': 'text-gray-400',
      'gateway': 'text-orange-400',
      'planner': 'text-pink-400',
      'chairman': 'text-teal-400',
      'stream': 'text-cyan-300'
    };
    
    function log(msg, type = 'info', data = null) {
      const div = document.createElement('div');
      div.className = `log-entry ${LOG_COLORS[type] || 'text-gray-400'} leading-relaxed`;
      
      const time = new Date().toLocaleTimeString('en-US', { hour12: false });
      const prefix = type.toUpperCase().padEnd(12);
      
      let html = `<span class="text-gray-600">${time}</span> <span class="font-semibold">[${prefix}]</span> ${escapeHtml(msg)}`;
      
      if (data) {
        // Deep parse any escaped JSON strings in the data
        const parsed = deepParseJson(data);
        const dataStr = JSON.stringify(parsed, null, 2);
        html += `<pre class="mt-1 ml-4 text-[10px] text-gray-500 bg-black/30 p-2 rounded whitespace-pre-wrap break-words">${escapeHtml(dataStr)}</pre>`;
      }
      
      div.innerHTML = html;
      debugLogs.appendChild(div);
      debugLogs.scrollTop = debugLogs.scrollHeight;
    }
    
    // Recursively parse JSON strings within objects
    function deepParseJson(obj) {
      if (typeof obj === 'string') {
        // Try to parse if it looks like JSON
        if (obj.trim().startsWith('{') || obj.trim().startsWith('[')) {
          try {
            return deepParseJson(JSON.parse(obj));
          } catch (e) {
            return obj;
          }
        }
        return obj;
      }
      if (Array.isArray(obj)) {
        return obj.map(deepParseJson);
      }
      if (obj && typeof obj === 'object') {
        const result = {};
        for (const [key, value] of Object.entries(obj)) {
          result[key] = deepParseJson(value);
        }
        return result;
      }
      return obj;
    }
    
    function escapeHtml(str) {
      const div = document.createElement('div');
      div.textContent = str;
      return div.innerHTML;
    }
    
    function clearLogs() {
      debugLogs.innerHTML = '';
      log('Logs cleared', 'info');
    }
    
    function toggleDebugPanel() {
      debugPanelVisible = !debugPanelVisible;
      debugPanel.style.width = debugPanelVisible ? '450px' : '0px';
      debugPanel.style.opacity = debugPanelVisible ? '1' : '0';
      document.getElementById('toggleDebugText').textContent = debugPanelVisible ? 'Hide Debug' : 'Show Debug';
    }
    
    // ‚îÄ‚îÄ Tab switching ‚îÄ‚îÄ
    function switchTab(tab) {
      activeTab = tab;
      const tabDebugBtn = document.getElementById('tabDebug');
      const tabAgentsBtn = document.getElementById('tabAgents');
      const contentDebug = document.getElementById('tabContentDebug');
      const contentAgents = document.getElementById('tabContentAgents');
      
      if (tab === 'debug') {
        tabDebugBtn.classList.remove('tab-inactive'); tabDebugBtn.classList.add('tab-active');
        tabAgentsBtn.classList.remove('tab-active'); tabAgentsBtn.classList.add('tab-inactive');
        contentDebug.classList.remove('hidden');
        contentAgents.classList.add('hidden');
      } else {
        tabAgentsBtn.classList.remove('tab-inactive'); tabAgentsBtn.classList.add('tab-active');
        tabDebugBtn.classList.remove('tab-active'); tabDebugBtn.classList.add('tab-inactive');
        contentAgents.classList.remove('hidden');
        contentDebug.classList.add('hidden');
      }
    }
    
    // ‚îÄ‚îÄ Agent task management ‚îÄ‚îÄ
    function formatElapsed(ms) {
      const s = Math.floor(ms / 1000);
      if (s < 60) return s + 's';
      const m = Math.floor(s / 60);
      return m + 'm ' + (s % 60) + 's';
    }
    
    function getStatusColor(status) {
      if (status === 'running') return 'bg-dot-cyan';
      if (status === 'completed') return 'bg-green-500';
      if (status === 'researching') return 'bg-purple-400';
      if (status === 'blocked') return 'bg-yellow-400';
      return 'bg-red-500';
    }

    function getStatusLabel(status) {
      if (status === 'running') return 'Running';
      if (status === 'completed') return 'Done';
      if (status === 'researching') return 'Researching';
      if (status === 'blocked') return 'Blocked';
      return 'Failed';
    }
    
    function updateAgentBadge() {
      const running = [...agentTasks.values()].filter(t => t.status === 'running').length;
      if (running > 0) {
        agentCountBadge.textContent = running;
        agentCountBadge.classList.remove('hidden');
        agentCountBadge.classList.add('flex');
      } else {
        agentCountBadge.classList.add('hidden');
        agentCountBadge.classList.remove('flex');
      }
    }
    
    function renderTimelineEvent(ev) {
      const ts = new Date(ev.timestamp).toLocaleTimeString('en-US', { hour12: false, hour: '2-digit', minute: '2-digit', second: '2-digit' });
      const icon = ev.eventType === 'tool_call' ? '‚Üí' : ev.eventType === 'tool_result' ? (ev.success ? '‚úì' : '‚úó') : '‚óè';
      const successClass = ev.eventType === 'tool_result' ? (ev.success ? 'success' : 'fail') : '';
      return `<div class="timeline-event ${ev.eventType || 'status'} ${successClass} py-0.5 flex gap-2">
        <span class="text-gray-600 shrink-0">${ts}</span>
        <span class="shrink-0">${icon}</span>
        <span class="truncate">${escapeHtml(ev.message || '')}</span>
      </div>`;
    }
    
    function copyAgentLog(taskId, event) {
      event.stopPropagation();
      const task = agentTasks.get(taskId);
      if (!task) return;
      
      const header = `${task.taskName} [${task.personaId}] ‚Äî ${getStatusLabel(task.status)}`;
      const elapsed = task.completedAt
        ? formatElapsed(task.completedAt - task.startedAt)
        : formatElapsed(Date.now() - task.startedAt);
      
      const lines = [header, `Duration: ${elapsed} | Tool calls: ${task.toolCalls} | Events: ${task.events.length}`, ''];
      for (const ev of task.events) {
        const ts = new Date(ev.timestamp).toLocaleTimeString('en-US', { hour12: false, hour: '2-digit', minute: '2-digit', second: '2-digit' });
        const icon = ev.eventType === 'tool_call' ? '‚Üí' : ev.eventType === 'tool_result' ? (ev.success ? '‚úì' : '‚úó') : '‚óè';
        lines.push(`${ts} ${icon} ${ev.message || ''}`);
      }
      
      navigator.clipboard.writeText(lines.join('\n')).then(() => {
        const btn = document.querySelector(`[data-copy="${taskId}"]`);
        if (btn) { btn.textContent = '‚úì'; setTimeout(() => { btn.textContent = '‚ßâ'; }, 1500); }
      });
    }
    
    function renderAgentCard(task) {
      const elapsed = task.completedAt
        ? formatElapsed(task.completedAt - task.startedAt)
        : formatElapsed(Date.now() - task.startedAt);

      const statusClass = task.status === 'completed' ? 'completed' : task.status === 'failed' ? 'failed' : task.status === 'researching' ? 'researching' : task.status === 'blocked' ? 'blocked' : '';
      const dotClass = ['running', 'researching'].includes(task.status) ? 'pulse-dot' : '';
      const chevron = task.expanded ? '‚ñæ' : '‚ñ∏';
      const eventCount = task.events.length;
      const roleLabel = task.agentRole ? escapeHtml(task.agentRole) : escapeHtml(task.personaId);
      const hasConvo = task.conversation && task.conversation.length > 0;

      let timelineHtml = '';
      if (task.expanded && eventCount > 0) {
        timelineHtml = `<div class="agent-timeline mt-2 pt-2 border-t border-gray-800 scrollbar-thin">
          ${task.events.map(renderTimelineEvent).join('')}
        </div>`;
      }

      return `
        <div class="agent-card ${statusClass} bg-gray-900/60 rounded-r-lg p-3 space-y-1" data-task-id="${escapeHtml(task.taskId)}">
          <div class="flex items-center justify-between">
            <div class="flex items-center gap-2">
              <span class="w-2 h-2 rounded-full ${getStatusColor(task.status)} ${dotClass}"></span>
              <span class="text-xs font-semibold text-gray-200 truncate max-w-[220px]">${escapeHtml(task.taskName)}</span>
            </div>
            <div class="flex items-center gap-3">
              <span class="text-[10px] text-gray-500 font-mono" data-elapsed="${task.taskId}">${elapsed}</span>
              ${hasConvo ? `<span class="text-[10px] text-dot-cyan hover:text-cyan-300 cursor-pointer" data-view-convo="${escapeHtml(task.taskId)}" title="View conversation">üí¨</span>` : ''}
              <span class="text-[11px] text-gray-600 hover:text-gray-300 cursor-pointer" data-copy-log="${escapeHtml(task.taskId)}" title="Copy log">‚ßâ</span>
              <span class="text-[10px] text-gray-600">${chevron}</span>
            </div>
          </div>
          <div class="flex items-center gap-2 text-[11px]">
            <span class="px-1.5 py-0.5 bg-gray-800 rounded text-gray-400">${roleLabel}</span>
            <span class="text-gray-500">${getStatusLabel(task.status)}</span>
            ${task.toolCalls > 0 ? `<span class="text-gray-600">&middot; ${task.toolCalls} tool calls</span>` : ''}
            ${eventCount > 0 ? `<span class="text-gray-600">&middot; ${eventCount} events</span>` : ''}
          </div>
          ${task.activity ? `<div class="text-[10px] text-gray-500 truncate">${escapeHtml(task.activity)}</div>` : ''}
          ${timelineHtml}
        </div>`;
    }
    
    function toggleAgentCard(taskId) {
      const task = agentTasks.get(taskId);
      if (!task) return;
      task.expanded = !task.expanded;
      refreshAgentPanel();
    }
    
    function refreshAgentPanel() {
      if (agentTasks.size === 0) {
        noAgentsMsg.classList.remove('hidden');
        agentTasksList.innerHTML = '';
        agentTasksList.appendChild(noAgentsMsg);
        return;
      }
      noAgentsMsg.classList.add('hidden');
      
      // Sort: running first, then by startedAt desc
      const sorted = [...agentTasks.values()].sort((a, b) => {
        if (a.status === 'running' && b.status !== 'running') return -1;
        if (a.status !== 'running' && b.status === 'running') return 1;
        return b.startedAt - a.startedAt;
      });
      
      agentTasksList.innerHTML = sorted.map(renderAgentCard).join('');
      updateAgentBadge();
      // CLIENT-01: Event delegation for agent card clicks (replaces inline onclick)
      agentTasksList.querySelectorAll('.agent-card[data-task-id]').forEach(card => {
        card.addEventListener('click', (e) => {
          if (e.target.closest('[data-copy-log]') || e.target.closest('[data-view-convo]')) return;
          toggleAgentCard(card.dataset.taskId);
        });
      });
      agentTasksList.querySelectorAll('[data-copy-log]').forEach(btn => {
        btn.addEventListener('click', (e) => {
          e.stopPropagation();
          copyAgentLog(btn.dataset.copyLog, e);
        });
      });
      agentTasksList.querySelectorAll('[data-view-convo]').forEach(btn => {
        btn.addEventListener('click', (e) => {
          e.stopPropagation();
          showAgentConvo(btn.dataset.viewConvo);
        });
      });
    }
    
    function trackAgentStarted(payload) {
      agentTasks.set(payload.taskId, {
        taskId: payload.taskId,
        taskName: payload.taskName || payload.taskId,
        personaId: payload.personaId || 'unknown',
        agentRole: payload.agentRole || null,
        status: 'running',
        startedAt: Date.now(),
        completedAt: null,
        activity: '',
        toolCalls: 0,
        events: [{ timestamp: Date.now(), eventType: 'status', message: 'Agent started' }],
        conversation: [],
        expanded: true,
      });
      refreshAgentPanel();
      
      // Auto-switch to Agents tab on first agent
      if (agentTasks.size === 1 && activeTab === 'debug') {
        switchTab('agents');
      }
      
      // Start elapsed timer ‚Äî clear any stale interval first to prevent duplicates
      if (agentTimerInterval) clearInterval(agentTimerInterval);
      {
        agentTimerInterval = setInterval(() => {
          // Update elapsed time for running tasks
          if (activeTab === 'agents') {
            for (const task of agentTasks.values()) {
              if (task.status !== 'running') continue;
              const el = document.querySelector(`[data-elapsed="${task.taskId}"]`);
              if (el) el.textContent = formatElapsed(Date.now() - task.startedAt);
            }
          }
          // Purge completed tasks older than 5 minutes to prevent unbounded growth
          const cutoff = Date.now() - 5 * 60 * 1000;
          for (const [id, task] of agentTasks) {
            if (task.completedAt && task.completedAt < cutoff) {
              agentTasks.delete(id);
            }
          }
        }, 1000);
      }
    }
    
    function trackAgentComplete(payload) {
      const task = agentTasks.get(payload.taskId);
      if (!task) return;
      task.status = payload.success ? 'completed' : 'failed';
      task.completedAt = Date.now();
      task.activity = payload.success ? 'Completed successfully' : 'Task failed';
      if (payload.agentRole) task.agentRole = payload.agentRole;
      if (Array.isArray(payload.conversation)) task.conversation = payload.conversation;
      task.events.push({ timestamp: Date.now(), eventType: 'status', message: task.activity, success: payload.success });
      refreshAgentPanel();
      
      // Auto-remove successful tasks after a brief delay so the user sees the success state
      if (payload.success) {
        setTimeout(() => {
          agentTasks.delete(payload.taskId);
          refreshAgentPanel();
        }, 3000);
      }
      
      // Stop timer if no running tasks
      const hasRunning = [...agentTasks.values()].some(t => t.status === 'running');
      if (!hasRunning && agentTimerInterval) {
        clearInterval(agentTimerInterval);
        agentTimerInterval = null;
      }
    }
    
    function trackAgentProgress(payload) {
      let task = null;
      
      // Prefer explicit taskId routing for concurrent agent accuracy
      if (payload.taskId && agentTasks.has(payload.taskId)) {
        task = agentTasks.get(payload.taskId);
      } else {
        // Fallback: last running task (warn if ambiguous)
        const running = [...agentTasks.values()].filter(t => t.status === 'running');
        if (running.length > 1) {
          log('Progress message missing taskId with ' + running.length + ' concurrent tasks ‚Äî routing may be incorrect', 'error');
        }
        if (running.length > 0) task = running[running.length - 1];
      }
      
      if (!task || !payload.message) return;
      task.activity = payload.message;
      // Update status if the server sent a status change (researching, blocked, etc.)
      if (payload.status && ['running', 'researching', 'blocked'].includes(payload.status)) {
        task.status = payload.status;
      }
      // Only count tool_call events, not tool_result (avoid double-counting)
      if (!payload.eventType || payload.eventType === 'tool_call') {
        task.toolCalls = (task.toolCalls || 0) + 1;
      }
      task.events.push({
        timestamp: Date.now(),
        eventType: payload.eventType || 'tool_call',
        message: payload.message,
        tool: payload.tool,
        success: payload.success,
      });
      // Cap events at 200 to prevent memory issues
      if (task.events.length > 200) task.events = task.events.slice(-200);
      refreshAgentPanel();
    }
    
    // WS-02: Exponential backoff state
    let reconnectDelay = 1000;
    const RECONNECT_MAX_DELAY = 30000;
    
    // WS-01: Heartbeat state
    let pingInterval = null;
    let pongTimeout = null;
    
    function safeSend(data) {
      if (ws && ws.readyState === WebSocket.OPEN) {
        ws.send(data);
        return true;
      }
      log('safeSend: WebSocket not open (state=' + (ws ? ws.readyState : 'null') + ')', 'error');
      return false;
    }
    
    function startHeartbeat() {
      stopHeartbeat();
      pingInterval = setInterval(() => {
        if (safeSend(JSON.stringify({ type: 'ping', id: 'ping_' + Date.now(), timestamp: Date.now(), payload: {} }))) {
          pongTimeout = setTimeout(() => {
            log('Ping timeout ‚Äî forcing reconnect', 'error');
            if (ws) ws.close();
          }, 10000);
        }
      }, 30000);
    }
    
    function stopHeartbeat() {
      if (pingInterval) { clearInterval(pingInterval); pingInterval = null; }
      if (pongTimeout) { clearTimeout(pongTimeout); pongTimeout = null; }
    }
    
    function connect() {
      log('Connecting to ' + WS_URL, 'client-send');
      
      ws = new WebSocket(WS_URL);
      
      ws.onopen = () => {
        log('WebSocket connected', 'info');
        reconnectDelay = 1000;
        const authMsg = {
          type: 'auth',
          id: 'auth_' + Date.now(),
          timestamp: Date.now(),
          payload: {
            deviceToken: 'web-client-token',
            deviceId: DEVICE_ID || `web_${Math.random().toString(36).substr(2, 9)}`,
            deviceSecret: DEVICE_SECRET || 'missing',
            deviceName: 'Web Browser',
            capabilities: ['prompt'],
            hwFingerprint: 'browser'
          }
        };
        log('Sending auth request', 'client-send', authMsg);
        safeSend(JSON.stringify(authMsg));
        startHeartbeat();
      };
      
      ws.onmessage = (event) => {
        try {
          const msg = JSON.parse(event.data);
          if (msg.type === 'pong') {
            if (pongTimeout) { clearTimeout(pongTimeout); pongTimeout = null; }
            return;
          }
          handleMessage(msg);
        } catch (err) {
          log('Failed to parse message: ' + err.message, 'error');
        }
      };
      
      ws.onclose = () => {
        log('WebSocket disconnected', 'error');
        stopHeartbeat();
        setConnected(false);
        if (!authErrorReason) {
          log('Reconnecting in ' + (reconnectDelay / 1000) + 's', 'info');
          setTimeout(connect, reconnectDelay);
          reconnectDelay = Math.min(reconnectDelay * 2, RECONNECT_MAX_DELAY);
        }
      };
      
      ws.onerror = (err) => {
        log('WebSocket error', 'error');
      };
    }
    
    let disconnectOverlayTimeout = null;
    function setConnected(connected) {
      isConnected = connected;
      statusDot.className = `w-2.5 h-2.5 rounded-full ${connected ? 'bg-green-500' : 'bg-red-500'}`;
      statusText.textContent = connected ? 'Connected' : 'Disconnected';
      sendBtn.disabled = !connected;
      
      const overlay = document.getElementById('disconnectOverlay');
      if (connected) {
        if (disconnectOverlayTimeout) { clearTimeout(disconnectOverlayTimeout); disconnectOverlayTimeout = null; }
        overlay.style.display = 'none';
      } else {
        // Delay overlay ‚Äî don't flash it during quick reconnects
        if (!disconnectOverlayTimeout) {
          disconnectOverlayTimeout = setTimeout(() => {
            if (!isConnected) overlay.style.display = 'flex';
            disconnectOverlayTimeout = null;
          }, 5000);
        }
      }
      document.getElementById('disconnectUrl').textContent = WS_URL;
      if (connected) {
        authErrorReason = '';
      } else if (authErrorReason) {
        document.getElementById('disconnectReason').textContent = authErrorReason;
        document.getElementById('reconnectStatus').textContent = 'Will not retry ‚Äî fix the issue and reconnect';
        document.getElementById('reconnectStatus').className = 'text-red-400 text-sm mb-4';
      } else {
        document.getElementById('disconnectReason').textContent = 'Server connection lost';
        document.getElementById('reconnectStatus').textContent = 'Attempting to reconnect...';
        document.getElementById('reconnectStatus').className = 'text-dot-cyan text-sm mb-4';
      }
    }
    
    function handleMessage(msg) {
      switch (msg.type) {
        case 'auth':
          log('Auth response received', 'client-recv', msg.payload);
          if (msg.payload?.success) {
            setConnected(true);
            addMessage('Connected to DotBot server', 'system');
          }
          if (msg.payload?.provider) {
            llmProvider = msg.payload.provider;
            llmModel = msg.payload.model || 'default';
            llmInfo.textContent = `${llmProvider} / ${llmModel}`;
          }
          break;

        case 'auth_failed':
          log('Auth failed: ' + (msg.payload?.message || msg.payload?.reason), 'error');
          authErrorReason = msg.payload?.message || msg.payload?.reason || 'Authentication failed';
          addMessage('‚ö†Ô∏è ' + authErrorReason, 'system');
          setConnected(false);
          if (ws) { ws.onclose = null; ws.close(); ws = null; }
          break;
          
        case 'response':
          log('Final response received', 'client-recv', {
            success: msg.payload?.success,
            classification: msg.payload?.classification,
            responseLength: msg.payload?.response?.length,
            ...(msg.payload?.error && { error: msg.payload.error })
          });
          if (currentStreamMessage) {
            renderMarkdown(currentStreamMessage, currentStreamRaw);
            currentStreamMessage.classList.remove('border-l-2', 'border-dot-cyan');
            currentStreamMessage = null;
            currentStreamRaw = '';
          }
          if (msg.payload?.response) {
            // Parse response - may be JSON with content field or plain text
            let displayText = msg.payload.response;
            try {
              // Try to extract JSON content if response is JSON
              const jsonMatch = displayText.match(/```json\s*([\s\S]*?)\s*```/);
              if (jsonMatch) {
                const parsed = JSON.parse(jsonMatch[1]);
                displayText = parsed.content || displayText;
              } else if (displayText.trim().startsWith('{')) {
                const parsed = JSON.parse(displayText);
                displayText = parsed.content || displayText;
              }
            } catch (e) {
              // Not JSON, use as-is
            }
            addMessage(displayText, 'assistant');
          }
          break;
          
        case 'stream_chunk':
          if (!currentStreamMessage) {
            currentStreamMessage = addMessage('', 'assistant streaming');
            currentStreamRaw = '';
            log('Stream started', 'stream');
          }
          currentStreamRaw += msg.payload?.content || '';
          renderMarkdown(currentStreamMessage, currentStreamRaw);
          messagesEl.scrollTop = messagesEl.scrollHeight;
          break;
          
        case 'task_progress':
          log('Task progress', 'server', msg.payload);
          trackAgentProgress(msg.payload);
          break;
          
        case 'gateway_decision':
        case 'receptionist_decision':
          log('Receptionist decision', 'receptionist', msg.payload);
          break;
          
        case 'planner_output':
          log('Planner output', 'planner', msg.payload);
          break;
          
        case 'llm_request':
          log(`LLM Request [${msg.payload?.persona}] ‚Üí ${msg.payload?.provider}/${msg.payload?.model}`, 'llm', {
            promptLength: msg.payload?.promptLength,
            maxTokens: msg.payload?.maxTokens,
            messages: msg.payload?.messages?.map(m => ({
              role: m.role,
              content: m.content?.substring(0, 500) + (m.content?.length > 500 ? '...' : '')
            }))
          });
          // Update LLM info display
          if (msg.payload?.provider) {
            llmProvider = msg.payload.provider;
            llmModel = msg.payload.model;
            llmInfo.textContent = `${llmProvider} / ${llmModel}`;
          }
          break;
          
        case 'llm_response':
          log(`LLM Response [${msg.payload?.persona}] ‚Üê ${msg.payload?.duration}ms`, 'llm', {
            responseLength: msg.payload?.responseLength,
            response: msg.payload?.response?.substring(0, 1000) + (msg.payload?.response?.length > 1000 ? '...' : '')
          });
          break;

        case 'thread_update':
          log(`Thread update: ${msg.payload?.threadId}`, 'memory', msg.payload?.updates);
          break;

        case 'user_notification':
          log(`Notification: ${msg.payload?.title}`, 'server', {
            source: msg.payload?.source,
            message: msg.payload?.message,
            modelSlug: msg.payload?.modelSlug
          });
          if (msg.payload?.message) {
            const notifDiv = addMessage(`üîî ${msg.payload.title || 'Notification'}\n${msg.payload.message}`, 'system');
            if (msg.payload?.suggestedPrompt && notifDiv) {
              const btn = document.createElement('button');
              btn.textContent = msg.payload.suggestedLabel || 'ü§ñ Try to fix this';
              btn.className = 'mt-2 px-3 py-1.5 text-xs rounded bg-dot-cyan/20 text-dot-cyan border border-dot-cyan/30 hover:bg-dot-cyan/30 cursor-pointer transition-colors';
              btn.addEventListener('click', () => {
                const prompt = msg.payload.suggestedPrompt;
                btn.disabled = true;
                btn.textContent = 'Sending...';
                btn.className = btn.className.replace('cursor-pointer', 'cursor-default opacity-50');
                addMessage(prompt, 'user');
                const promptMsg = {
                  type: 'prompt',
                  id: 'prompt_' + Date.now(),
                  timestamp: Date.now(),
                  payload: { prompt, context: {} }
                };
                safeSend(JSON.stringify(promptMsg));
              });
              notifDiv.appendChild(btn);
            }
          }
          break;

        case 'agent_started':
          log(`Agent task started: ${msg.payload?.taskName || msg.payload?.taskId}`, 'server', {
            taskId: msg.payload?.taskId,
            taskName: msg.payload?.taskName,
            personaId: msg.payload?.personaId,
          });
          trackAgentStarted(msg.payload);
          break;

        case 'agent_complete':
          log(`Agent task completed: ${msg.payload?.taskId}`, 'server', {
            taskId: msg.payload?.taskId,
            success: msg.payload?.success,
            classification: msg.payload?.classification,
          });
          // Finalize any lingering stream from the background task
          if (currentStreamMessage) {
            renderMarkdown(currentStreamMessage, currentStreamRaw);
            currentStreamMessage.classList.remove('border-l-2', 'border-dot-cyan');
            currentStreamMessage = null;
            currentStreamRaw = '';
          }
          trackAgentComplete(msg.payload);
          if (msg.payload?.response) {
            addMessage(msg.payload.response, 'assistant', msg.payload?.agentRole || null);
          }
          break;

        case 'run_log':
          log('Run log received', 'server', {
            elapsedMs: msg.payload?.elapsedMs,
            entries: msg.payload?.entries?.length,
          });
          break;

        case 'error':
          log('Error received', 'error', msg.payload);
          addMessage('Error: ' + (msg.payload?.message || 'Unknown error'), 'system');
          break;
          
        default:
          log(`Unknown message type: ${msg.type}`, 'client-recv', msg);
      }
    }
    
    // Configure marked to open all links in new tabs
    const renderer = new marked.Renderer();
    renderer.link = function({ href, title, tokens }) {
      const text = this.parser.parseInline(tokens);
      const titleAttr = title ? ` title="${title}"` : '';
      return `<a href="${href}"${titleAttr} target="_blank" rel="noopener noreferrer">${text}</a>`;
    };
    marked.setOptions({ renderer });

    function renderMarkdown(el, raw) {
      try {
        const html = marked.parse(raw, { breaks: true, gfm: true });
        // Sanitize HTML to prevent XSS (M-04 fix)
        el.innerHTML = DOMPurify.sanitize(html);
        el.classList.add('md-content');
      } catch (e) {
        console.error('[MD] renderMarkdown FAILED:', e, 'raw length:', raw?.length, 'raw type:', typeof raw, 'first 200 chars:', String(raw).substring(0, 200));
        el.style.whiteSpace = 'pre-wrap';
        el.textContent = raw;
      }
    }

    function addMessage(content, className, agentRole) {
      const div = document.createElement('div');

      const baseClasses = 'px-4 py-3 rounded-lg max-w-[85%]';

      if (className.includes('user')) {
        div.className = `${baseClasses} bg-dot-user self-end rounded-br-sm ml-auto whitespace-pre-wrap`;
      } else if (className.includes('assistant')) {
        div.className = `${baseClasses} bg-dot-assistant self-start rounded-bl-sm`;
        if (className.includes('streaming')) {
          div.className += ' border-l-2 border-dot-cyan';
        }
      } else if (className.includes('system')) {
        div.className = `${baseClasses} bg-gray-800/50 text-gray-400 text-sm self-center text-center mx-auto whitespace-pre-wrap`;
      }

      // V2: Agent label on assistant messages
      if (agentRole && className.includes('assistant')) {
        const labelEl = document.createElement('div');
        labelEl.className = 'agent-label agent-label-default';
        labelEl.textContent = agentRole;
        div.appendChild(labelEl);
      }

      if (className.includes('assistant') && content) {
        const contentEl = document.createElement('div');
        renderMarkdown(contentEl, content);
        div.appendChild(contentEl);
      } else {
        const textNode = document.createTextNode(content);
        div.appendChild(textNode);
      }
      messagesEl.appendChild(div);
      messagesEl.scrollTop = messagesEl.scrollHeight;
      return div;
    }

    // V2: Show agent's isolated conversation in a modal
    function showAgentConvo(taskId) {
      const task = agentTasks.get(taskId);
      if (!task || !task.conversation || task.conversation.length === 0) return;
      const title = document.getElementById('agentConvoTitle');
      const body = document.getElementById('agentConvoBody');
      title.textContent = task.agentRole || task.taskName || 'Agent Conversation';
      body.innerHTML = '';
      for (const msg of task.conversation) {
        const row = document.createElement('div');
        const roleColor = msg.role === 'user' ? 'text-blue-400' : msg.role === 'assistant' ? 'text-green-400' : 'text-gray-500';
        row.className = `text-xs p-2 rounded ${msg.role === 'assistant' ? 'bg-gray-900/60' : 'bg-gray-800/40'}`;
        const roleSpan = `<span class="${roleColor} font-semibold uppercase text-[10px]">${escapeHtml(msg.role)}</span>`;
        const ts = msg.timestamp ? `<span class="text-gray-600 text-[10px] ml-2">${new Date(msg.timestamp).toLocaleTimeString('en-US', { hour12: false })}</span>` : '';
        row.innerHTML = `<div class="mb-1">${roleSpan}${ts}</div><div class="text-gray-300 whitespace-pre-wrap">${escapeHtml(msg.content?.substring(0, 2000) || '')}</div>`;
        if (msg.toolCalls && msg.toolCalls.length > 0) {
          const toolsHtml = msg.toolCalls.map(tc => `<div class="text-[10px] text-dot-cyan ml-2">‚Üí ${escapeHtml(tc.toolId)} ${escapeHtml(JSON.stringify(tc.input).substring(0, 120))}</div>`).join('');
          row.innerHTML += toolsHtml;
        }
        body.appendChild(row);
      }
      document.getElementById('agentConvoModal').classList.remove('hidden');
    }

    function closeAgentConvo() {
      document.getElementById('agentConvoModal').classList.add('hidden');
    }
    
    function sendMessage() {
      const text = inputEl.value.trim();
      if (!text || !isConnected) return;
      
      addMessage(text, 'user');
      inputEl.value = '';
      inputEl.style.height = 'auto';
      
      const promptMsg = {
        type: 'prompt',
        id: 'prompt_' + Date.now(),
        timestamp: Date.now(),
        payload: {
          prompt: text,
          context: {}
        }
      };
      
      log('Sending prompt', 'client-send', { prompt: text.substring(0, 100) + (text.length > 100 ? '...' : '') });
      safeSend(JSON.stringify(promptMsg));
    }
    
    function handleKeyDown(event) {
      if (event.key === 'Enter' && !event.shiftKey) {
        event.preventDefault();
        sendMessage();
      }
    }
    
    // Auto-resize textarea
    inputEl.addEventListener('input', () => {
      inputEl.style.height = 'auto';
      inputEl.style.height = Math.min(inputEl.scrollHeight, 200) + 'px';
    });
    
    // Server settings
    function showServerSettings() {
      document.getElementById('serverUrlInput').value = WS_URL;
      document.getElementById('serverSettingsModal').classList.remove('hidden');
      document.getElementById('serverUrlInput').focus();
    }
    
    function closeServerSettings() {
      document.getElementById('serverSettingsModal').classList.add('hidden');
    }
    
    function saveServerSettings() {
      const newUrl = document.getElementById('serverUrlInput').value.trim();
      if (!newUrl) return;
      localStorage.setItem('dotbot_ws_url', newUrl);
      WS_URL = newUrl;
      closeServerSettings();
      authErrorReason = '';
      if (ws) { ws.onclose = null; ws.close(); }
      connect();
    }
    
    // Start connection
    log('DotBot Client initialized', 'info');
    window.addEventListener('beforeunload', () => {
      if (ws) { try { ws.close(); } catch(e) {} }
      stopHeartbeat();
      if (agentTimerInterval) clearInterval(agentTimerInterval);
      if (disconnectOverlayTimeout) clearTimeout(disconnectOverlayTimeout);
    });
    
    log('Server: ' + WS_URL, 'info');
    log('Device ID: ' + DEVICE_ID, 'info');
    if (!DEVICE_ID || !DEVICE_SECRET) {
      log('No device credentials provided ‚Äî opening settings', 'info');
      log('Tip: Include deviceId and secret in URL hash to connect automatically', 'info');
      showServerSettings();
    } else {
      connect();
    }
  </script>
</body>
</html>
